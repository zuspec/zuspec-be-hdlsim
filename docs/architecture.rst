Architecture
============

System Architecture
-------------------

The Zuspec HDLSim backend implements a dual-domain architecture that partitions 
verification logic between SystemVerilog (for hardware simulation) and Python 
(for test orchestration).

.. code-block:: text

    ┌─────────────────────────────────────────────────────────┐
    │ Python Domain (pytest via PyHDL-IF)                     │
    ├─────────────────────────────────────────────────────────┤
    │  • Test Orchestration                                   │
    │  • Top-level Component                                  │
    │  • Python-only Components                               │
    │  • Test Sequences & Scenarios                           │
    └────────────────┬────────────────────────────────────────┘
                     │ PyHDL-IF Bridge
                     │ (TLM/API calls)
    ┌────────────────┴────────────────────────────────────────┐
    │ SystemVerilog Domain (HDL Simulator)                    │
    ├─────────────────────────────────────────────────────────┤
    │  • Generated Testbench Module                           │
    │  • Generated Transactors (XtorComponent)                │
    │  • Extern Components (existing HDL)                     │
    │  • Signal-level Connectivity                            │
    │  • DUT (Design Under Test)                              │
    └─────────────────────────────────────────────────────────┘

Component Classification
------------------------

The backend classifies components into three categories that determine their 
implementation domain:

Extern Components
^^^^^^^^^^^^^^^^^

**Purpose**: Wrap existing SystemVerilog modules for use in Zuspec testbenches

**Implementation**: SystemVerilog only (pre-existing or provided by user)

**Characteristics**:
  * Inherit from ``Extern`` protocol
  * Reference existing HDL modules
  * Provide SystemVerilog source filesets via ``@annotation_fileset``
  * Connect to other SV components via signals/interfaces

**Example**:

.. code-block:: python

    @zdc.dataclass
    class DutWrapper(zdc.Component, Extern):
        """Wrapper for existing DUT module."""
        
        @annotation_fileset(sources=["dut.sv"])
        def __post_init__(self):
            pass

XtorComponent Transactors
^^^^^^^^^^^^^^^^^^^^^^^^^^

**Purpose**: Define transactors that generate both SystemVerilog and Python APIs

**Implementation**: SystemVerilog (generated) + Python proxy (runtime)

**Characteristics**:
  * Inherit from ``XtorComponent[Protocol]``
  * Protocol defines the transaction API
  * SV code generated by zuspec-be-sv
  * Python API wrapper generated via PyHDL-IF
  * Connect via ``xtor_if`` interface

**Example**:

.. code-block:: python

    @zdc.dataclass
    class ClkGenXtor(XtorComponent[ClkGenIf]):
        """Clock generator transactor."""
        
        clock: Signal = zdc.output()
        
        async def start(self, freq_mhz: int):
            """Start clock generation."""
            ...

Python Components
^^^^^^^^^^^^^^^^^

**Purpose**: Pure Python verification components

**Implementation**: Python only

**Characteristics**:
  * Standard Zuspec components
  * No signal-level connectivity to SV domain
  * Communicate via TLM/method calls
  * Run in pytest environment

Domain Separation Rules
-----------------------

The HDLTestbench profile enforces strict domain separation:

1. **No Signal-Level Crossing**: Python components cannot connect directly to 
   signals in the SV domain
   
2. **TLM Boundary**: Communication between domains uses transaction-level 
   modeling (method calls on xtor_if)
   
3. **Extern Isolation**: Extern components can only connect to other SV 
   components (Extern or XtorComponent)

Generation Flow
---------------

Build Time (GenTB Task)
^^^^^^^^^^^^^^^^^^^^^^^^

1. **Profile Checking**: HDLTestbenchChecker validates domain separation rules
2. **SV Generation**: 
   
   * Generate transactor modules (via zuspec-be-sv)
   * Generate testbench wrapper module
   * Generate PyHDL-IF API definitions (JSON)
   
3. **API Generation**: PyHDL-IF generates SV/Python API glue code
4. **Fileset Output**: Produce ordered compilation fileset

Runtime (Simulation)
^^^^^^^^^^^^^^^^^^^^

1. **Simulator Launch**: HDL simulator loads compiled testbench
2. **Registration**: SV testbench registers transactor APIs with PyHDL-IF
3. **pytest Launch**: SV calls ``pyhdl_pytest()`` to start Python tests
4. **Factory Configuration**: HDLSimRuntime intercepts testbench construction
5. **Proxy Creation**: PyTestbenchFactory creates proxies to SV components
6. **Test Execution**: pytest runs, communicating with SV via proxies

Code Generation Details
-----------------------

Testbench Module Structure
^^^^^^^^^^^^^^^^^^^^^^^^^^^

The generated top-level testbench module has this structure:

.. code-block:: systemverilog

    module MyTB_tb;
        import pyhdl_if::*;
        import RVXtor::*;
        
        // Instance HDL components
        MyTB_hdl u_hdl();
        
        initial begin
            // Register transactors with PyHDL-IF
            // ... registration code ...
            
            // Configure Python ObjFactory
            pyhdl_configure_objfactory("mypackage.MyTB");
            
            // Launch pytest
            pyhdl_pytest();
            
            $finish;
        end
    endmodule

HDL Module Structure
^^^^^^^^^^^^^^^^^^^^

The ``_hdl`` module contains the hardware components:

.. code-block:: systemverilog

    module MyTB_hdl;
        // Extern component instances
        dut u_dut(...);
        
        // Generated transactor instances
        RVXtor u_xtor(...);
        
        // Signal bindings from __bind__
        assign u_dut.rv_if = u_xtor.xtor_if;
    endmodule

Python Runtime Factory
^^^^^^^^^^^^^^^^^^^^^^

At runtime, the ``PyTestbenchFactory`` creates proxy objects:

.. code-block:: python

    class TestbenchProxy:
        def __init__(self):
            # Look up registered SV components via PyHDL-IF
            self.xtor = HdlObjRgy.inst().find("top.xtor")
            self.dut = None  # Extern, no Python API

Key Classes
-----------

* ``SVTestbenchGenerator``: Generates SystemVerilog testbench modules
* ``PyTestbenchFactory``: Creates runtime proxy objects for Python tests
* ``HDLTestbenchChecker``: Validates profile rules
* ``TransactorJsonApiGenerator``: Generates PyHDL-IF API definitions
* ``GenTB``: DFM task for testbench generation

See :doc:`api_reference` for detailed API documentation.
